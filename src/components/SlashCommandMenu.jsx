import { useState, useEffect, useImperativeHandle, forwardRef } from 'react'

const SlashCommandMenu = forwardRef(({ editor, range, onClose }, ref) => {
  const [selectedIndex, setSelectedIndex] = useState(0)

  const commands = [
    {
      title: 'Summarize',
      description: 'Generate an AI summary',
      command: async () => {
        if (range) {
          // Step 1: Get the full editor content BEFORE inserting placeholder
          const fullText = editor.getText().replace('/summarize', '').trim()

          // Check if there's content to summarize
          if (!fullText || fullText.length < 10) {
            // No content yet - insert a prompt for the user to add content
            editor
              .chain()
              .focus()
              .deleteRange(range)
              .insertContent('📝 Please paste or type your content above this line, then use /summarize again to summarize it.')
              .run()
            return
          }

          // Step 2: Delete the "/summarize" text and insert placeholder
          editor
            .chain()
            .focus()
            .deleteRange(range)
            .insertContent('🔄 Generating summary...')
            .run()

          try {
            // Step 3: Send request to summarize API
            console.log('Sending request to /api/summarize with text:', fullText.substring(0, 100) + '...')

            let response, data

            try {
              response = await fetch('/api/summarize', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ text: fullText }),
              })

              console.log('Response status:', response.status)
              console.log('Response ok:', response.ok)

              data = await response.json()
              console.log('Response data:', data)
            } catch (fetchError) {
              // Fallback for local development - simulate API response
              console.log('API not available, using mock response for testing')
              await new Promise(resolve => setTimeout(resolve, 2000)) // Simulate delay

              response = { ok: true }
              data = {
                summary: `This is a mock summary of your text. In production, this would be generated by GPT-4. Your text was ${fullText.length} characters long and contained topics about AI and technology.`
              }
              console.log('Mock response data:', data)
            }

            if (response.ok && data.summary) {
              // Step 4: Replace placeholder with summary
              // Find and replace the loading message
              const { from, to } = editor.state.selection
              const doc = editor.state.doc
              let loadingPos = null

              // Search for the loading message
              doc.descendants((node, pos) => {
                if (node.isText && node.text.includes('🔄 Generating summary...')) {
                  loadingPos = { from: pos, to: pos + node.text.length }
                  return false
                }
              })

              if (loadingPos) {
                editor
                  .chain()
                  .focus()
                  .setTextSelection(loadingPos)
                  .deleteSelection()
                  .insertContent(`📝 ${data.summary}`)
                  .run()
              } else {
                // Fallback: just insert at current position
                editor
                  .chain()
                  .focus()
                  .insertContent(`📝 ${data.summary}`)
                  .run()
              }
            } else {
              // Handle API error response
              const errorMessage = data.error || 'Unknown error occurred'
              // Find and replace the loading message
              const doc = editor.state.doc
              let loadingPos = null

              doc.descendants((node, pos) => {
                if (node.isText && node.text.includes('🔄 Generating summary...')) {
                  loadingPos = { from: pos, to: pos + node.text.length }
                  return false
                }
              })

              if (loadingPos) {
                editor
                  .chain()
                  .focus()
                  .setTextSelection(loadingPos)
                  .deleteSelection()
                  .insertContent(`❌ GPT Error: ${errorMessage}`)
                  .run()
              }
            }
          } catch (error) {
            // Step 5: Handle network/fetch errors
            console.error('Summarize error:', error)
            // Find and replace the loading message
            const doc = editor.state.doc
            let loadingPos = null

            doc.descendants((node, pos) => {
              if (node.isText && node.text.includes('🔄 Generating summary...')) {
                loadingPos = { from: pos, to: pos + node.text.length }
                return false
              }
            })

            if (loadingPos) {
              editor
                .chain()
                .focus()
                .setTextSelection(loadingPos)
                .deleteSelection()
                .insertContent('❌ GPT Error: Failed to connect to summarize service')
                .run()
            }
          }
        }
        onClose()
      },
    },
    {
      title: 'Generate Title',
      description: 'Create a title for your content',
      command: () => {
        if (range) {
          editor
            .chain()
            .focus()
            .deleteRange(range)
            .insertContent('Generated title goes here...')
            .run()
        }
        onClose()
      },
    },
    {
      title: 'Ask Question',
      description: 'Ask AI a question',
      command: () => {
        if (range) {
          editor
            .chain()
            .focus()
            .deleteRange(range)
            .insertContent('AI answer goes here...')
            .run()
        }
        onClose()
      },
    },
  ]

  useImperativeHandle(ref, () => ({
    onKeyDown: ({ event }) => {
      if (event.key === 'ArrowDown') {
        setSelectedIndex((selectedIndex + 1) % commands.length)
        return true
      }

      if (event.key === 'ArrowUp') {
        setSelectedIndex((selectedIndex + commands.length - 1) % commands.length)
        return true
      }

      if (event.key === 'Enter') {
        selectItem(selectedIndex)
        return true
      }

      return false
    },
  }))

  const selectItem = (index) => {
    const item = commands[index]
    if (item) {
      item.command()
    }
  }

  useEffect(() => {
    setSelectedIndex(0)
  }, [])

  return (
    <div className="fixed z-50 bg-white rounded-lg shadow-lg border border-gray-200 py-2 w-48">
      {commands.map((item, index) => (
        <button
          key={index}
          className={`w-full text-left px-4 py-3 hover:bg-gray-100 transition-colors ${
            index === selectedIndex ? 'bg-gray-100' : ''
          }`}
          onClick={() => selectItem(index)}
          onMouseEnter={() => setSelectedIndex(index)}
        >
          <div className="font-medium text-gray-900">{item.title}</div>
          <div className="text-sm text-gray-500">{item.description}</div>
        </button>
      ))}
    </div>
  )
})

SlashCommandMenu.displayName = 'SlashCommandMenu'

export default SlashCommandMenu
